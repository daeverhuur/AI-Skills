# Power Platform: ALM, Administration, and Connectors

> Research compiled from Microsoft Learn documentation (2026-02-26)

---

## 1. Application Lifecycle Management (ALM) Overview

ALM is the lifecycle management of applications covering governance, development, and maintenance. It combines disciplines such as requirements management, software architecture, development, testing, deployment, release management, and governance.

**Key areas:**

| Area | Scope |
|------|-------|
| **Governance** | Requirements management, resource management, data security, user access, change tracking, audit, deployment control, rollback |
| **Application Development** | Problem identification, planning, design, building, testing, continuous improvement |
| **Maintenance** | Deployment, maintenance of dependent technologies, monitoring |

**Core concepts for Power Platform ALM:**
- **Solutions** are the transport mechanism -- export/import components across environments
- **Dataverse** stores all artifacts including solutions and in-product deployment pipelines
- **Source control** is the single source of truth for components
- **CI/CD platforms** (Azure DevOps, GitHub Actions) automate build, test, and deploy pipelines

All environments participating in ALM must include a Dataverse database.

---

## 2. Solutions: Managed vs. Unmanaged

### Unmanaged Solutions
- Used in **development environments** while making changes
- Can be exported as either unmanaged or managed
- Should be checked into source control
- Deleting an unmanaged solution removes only the container; customizations remain in the default solution

### Managed Solutions
- Deployed to **non-development** environments (test, UAT, SIT, production)
- Can be serviced independently (upgrade, patch, delete)
- Should be generated by a build server as a build artifact
- Cannot edit components directly within a managed solution
- Deleting a managed solution removes all customizations and extensions included with it
- Data stored in custom tables/columns is lost when deleting

### Solution Lifecycle Actions

| Action | Description |
|--------|-------------|
| **Create** | Author and export unmanaged solutions |
| **Update** | Deploy changes to a parent managed solution; cannot delete components |
| **Upgrade** | Import as upgrade to existing managed solution; removes unused components; merges patches |
| **Patch** | Contains only changes (hotfix-like); layered on top of parent; cannot delete components |

### Solution Publisher
- Every solution has a publisher that owns its components
- Publisher prefix prevents naming collisions (e.g., `contoso_`)
- Cannot change publisher after components are in a managed solution
- Best practice: define a single publisher to allow flexible layering across solutions later

### Solution Components
- Anything included in a solution: tables, columns, apps, flows, agents, charts, plug-ins, custom connectors
- Maximum solution size: 95 MB
- Some components are nested (e.g., columns within tables)
- System tracks dependencies between solutions for install/uninstall ordering

---

## 3. Solution Layers

Solution layering is implemented at the component level with two distinct layers:

| Layer | Description |
|-------|-------------|
| **Unmanaged** | All imported unmanaged solutions and ad-hoc customizations share a single layer |
| **Managed** | All imported managed solutions stacked in install order; system solution at the base |

**Merge behavior:**
- Model-driven apps, forms, and site maps use **merge** logic
- All other components use **"top wins"** behavior (highest layer determines runtime behavior)

**Layers within a managed solution:**
- **Base layer** -- bottom of the stack; includes publisher and managed properties
- **Patches** -- stacked on top of base, most recent on top
- **Pending upgrade** -- staged upgrade resides on top of base and patches
- Applying an upgrade flattens all layers (base + patches) into a new base

Using patches is **not recommended** by Microsoft; prefer full solution upgrades.

---

## 4. Environment Strategy

### Recommended Environment Types

| Type | Purpose | Access |
|------|---------|--------|
| **Development (Sandbox)** | Build and test with low risk; supports reset/delete/copy | App makers, developers |
| **Test** | End-to-end validation including deployment testing | Admins, testers |
| **UAT/SIT** | User acceptance and integration testing | Admins, selected users |
| **Production** | Live environment for end users | Admins, app users |
| **Developer** | Single-user environment for learning/building (free plan) | Individual developer |
| **Default** | Auto-created per tenant; shared by all users | All users (restrict this) |

**Best practices:**
- Minimum: separate dev + test + production environments
- Developers should have at least Environment Maker security role
- Production users should have only necessary privileges
- Isolate development work to avoid conflicts between makers

### Multi-Geographical Considerations
- Service updates roll out across 6 stations by region
- Dev environments should be in the **same or earlier station** as production
- Solutions can be imported into newer environments but not reliably into older ones
- Example: dev in North America (station 5) for production in Canada (station 2) or US (station 5)

---

## 5. DevOps Build Tools (Azure DevOps)

Power Platform Build Tools automate common build and deployment tasks. Version 2.0 is CLI-based (replacing PowerShell-based v1.0).

### Task Categories

| Category | Tasks |
|----------|-------|
| **Helper** | Tool installer, Power Platform environment setup |
| **Quality Check** | Power Apps Checker (static analysis, outputs SARIF file) |
| **Solution** | Export, import, unpack, pack, clone, publish customizations |
| **Environment Management** | Create, copy, reset, backup, restore, delete environments |

### Common Pipeline Patterns
1. **Initiate** -- set up and configure
2. **Export from Dev** -- export unmanaged solution
3. **Build** -- generate managed solution artifact
4. **Release** -- deploy to downstream environments

### Service Connection Types

| Type | Description |
|------|-------------|
| **Workload Identity Federation** (recommended) | Service principal via federated credentials; supports MFA |
| **Service principal + client secret** | App registration with secret |
| **Username/password** | Generic; does not support MFA |

### Setup Steps
1. Install from Azure Marketplace
2. Create app registration in Microsoft Entra ID
3. Run `pac admin create-service-principal --environment <id>`
4. Configure Application User with System Administrator role
5. Create service connection in Azure DevOps

---

## 6. GitHub Actions for Power Platform

GitHub Actions provide the same CLI-based tasks as Build Tools but for GitHub workflows.

### Setup Requirements
1. Create three Dataverse environments (dev, build, prod) -- minimum 3 GB capacity
2. Register app in Microsoft Entra ID with API permissions:
   - Dynamics CRM (delegated `user_impersonation`)
   - PowerApps Runtime Service (delegated `user_impersonation`)
   - PowerApps-Advisor (delegated `Analysis.All`)
3. Create client secret and store securely
4. Create Application User in each environment with System Administrator role

### Authentication
- Service principal is **required** when MFA is enabled
- Store credentials as GitHub Secrets

### Available Actions
- Export solution, import solution, unpack solution, pack solution
- Solution checker, publish customizations
- Create/delete/backup/restore environments
- Deploy using `pac pipeline` commands

---

## 7. Power Platform Pipelines (In-Product)

Pipelines are built-in ALM automation within Power Platform -- no external tools required.

### Key Features
- Admins configure deployment pipelines in minutes
- Makers deploy with a few clicks from their development environment
- Developers extend via Power Platform CLI (`pac pipeline` commands)
- Pre-deployment validation catches missing dependencies
- Connections and environment variables validated before deployment

### Architecture

| Component | Role |
|-----------|------|
| **Host environment** | Production environment storing pipeline configuration and artifacts |
| **Development environment** | Where makers build and initiate deployments |
| **Target environments** | QA, production, or other downstream stages |

### Deployment Behavior
- Solutions are exported when deployment is requested; same artifact flows through all stages
- Cannot skip stages (e.g., QA cannot be bypassed)
- Default import behavior: **Upgrade** without overwrite customizations
- Only managed solutions can be deployed (unmanaged stored for reference)
- Solution backups are stored automatically in the host

### Licensing

| Environment | License Required |
|-------------|-----------------|
| Host (production) | No |
| Development (developer) | No |
| QA (developer) | No |
| Production (target) | Yes (Managed Environment + premium license) |

### Delegation and Approvals
- Supports approval-based delegated deployments
- Different service principals can be used per pipeline/stage
- Cross-region deployments supported when enabled in host settings

---

## 8. Segmented Solutions (Table Segmentation)

Segmented solutions let you include only the specific table components that changed, rather than entire tables.

### Segmentation Options

| Option | What It Includes |
|--------|-----------------|
| **No objects selected** | Minimal table info only (default) |
| **Edit objects** | Select individual columns, forms, views, charts, etc. |
| **Include table metadata** | Table properties (auditing, change tracking) but no components |
| **Include all objects** | All components and metadata; use only for new tables |

**Best practice:** Only add changed components to avoid unnecessary solution layers. Adding unchanged components can make existing customizations inactive in lower layers.

**Warning:** If a table does not exist in the target environment, you **must** use "Include all objects" to avoid missing dependency errors.

---

## 9. Connectors

### Overview
Connectors enable Power Apps, Power Automate, Copilot Studio, and Logic Apps to communicate with external services. All connectors are agent-ready and expose **actions** (e.g., create a file) and **triggers** (e.g., when a new item is added).

### Connector Types

| Type | Description |
|------|-------------|
| **Prebuilt** | 1,000+ ready-made connectors (e.g., SharePoint, Outlook, SQL Server, Salesforce) |
| **Custom** | User-built connectors wrapping REST or SOAP APIs |

### Products Using Connectors
- Microsoft Copilot Studio
- Power Automate
- Power Apps
- Azure Logic Apps

Connectors created in Power Automate are available in Power Apps and Copilot Studio (and vice versa). Logic Apps connectors must be recreated.

---

## 10. Custom Connectors

Custom connectors wrap REST (or SOAP in Logic Apps) APIs not available as prebuilt connectors.

### Lifecycle

| Stage | Details |
|-------|---------|
| **1. Build API** | Public or private REST/SOAP API (Azure Functions, Web Apps, API Apps) |
| **2. Secure API** | OAuth 2.0, Microsoft Entra ID (recommended), Basic auth, API Key |
| **3. Describe API** | OpenAPI (Swagger) definition, Postman collection, or from scratch |
| **4. Use connector** | Same as prebuilt connectors in flows, apps, agents |
| **5. Share** | Share within organization |
| **6. Certify** | Submit for Microsoft certification for public availability |

### Authentication Methods
- **Generic OAuth 2.0** -- standard authorization code flow
- **Service-specific OAuth 2.0** -- Microsoft Entra ID, Dropbox, GitHub, Salesforce
- **Basic authentication** -- username/password
- **API Key** -- key-based access

### Creating from Web API (Step-by-Step)
1. Build ASP.NET Web API in Visual Studio
2. Deploy to Azure App Service
3. Install Swashbuckle NuGet package for OpenAPI generation
4. Access generated Swagger at `https://{root}/swagger/docs/v1`
5. Save OpenAPI JSON file
6. Register two Microsoft Entra ID apps:
   - First app secures the Web API itself
   - Second app secures the custom connector and provides delegated access
7. Enable App Service Authentication with Microsoft Entra ID
8. Add `securityDefinitions` to OpenAPI with OAuth 2.0 configuration
9. Register as custom connector in Power Automate/Power Apps
10. Configure Client ID, Client Secret, Login URL, and Resource URI

### Virtual Network Support
- Custom connectors work in VNet-linked environments with limitations
- Custom code has specific constraints
- Connectors created before VNet association need to be resaved

---

## 11. Well-Architected Framework

Power Platform Well-Architected provides best practices and architecture guidance for designing modern application workloads.

### Five Pillars

| Pillar | Focus |
|--------|-------|
| **Reliability** | Uptime and recovery targets; redundancy and resiliency at scale |
| **Security** | Protect workloads from attacks; confidentiality and data integrity |
| **Operational Excellence** | Reduce production issues; observability and automated systems |
| **Performance Efficiency** | Handle demand changes; horizontal scaling; test before deploy |
| **Experience Optimization** | Meaningful user experiences ensuring business outcomes |

### Resources
- Design review checklists per pillar
- Recommendation guides with tradeoff analysis
- Assessment tool at `https://aka.ms/powa/assessment`
- Architecture Center for Power Platform and Copilot Studio solutions

---

## 12. Governance and Adoption

### CoE (Center of Excellence) Starter Kit

The CoE Starter Kit is a collection of components for adopting and supporting Power Platform governance.

| Module | Purpose |
|--------|---------|
| **Admin** | Gain insights into adoption; inventory of apps, flows, and makers; Power BI dashboards |
| **Govern** | Audit and compliance processes; DLP policy management; environment management |
| **Nurture** | Community building; maker onboarding; training resources; app showcases |

**Setup:** Install as managed solution in a dedicated environment. Requires Dataverse, Power Automate, and Power BI.

### Adoption Methodology

| Pillar | Description |
|--------|-------------|
| **Strategy** | Document objectives, measurable key results, and key initiatives |
| **Plan** | Define roles, responsibilities, and delivery models |
| **Security** | Protect workloads and data; meet compliance requirements |
| **Governance** | Digital guardrails for makers to create with confidence |
| **Operations** | ALM strategy and ongoing production support |
| **Availability** | Plan for failures and disaster recovery |
| **Readiness** | Upskill makers; envision high-value use cases |
| **Community** | Internal community of practice; knowledge sharing |

**Target audiences:** CoE leads, line-of-business leaders, IT admins, CISOs, enterprise architects, business SMEs.

---

## 13. Power Apps Project Planning

### Project Phases

| Phase | Activities |
|-------|-----------|
| **Plan** | Identify who, what, when, and why |
| **Design** | Data modeling, screen sketches, conceptual and architectural design |
| **Make** | Build the app (canvas or model-driven) |
| **Test** | User testing and validation |
| **Deploy and Refine** | Distribution, feedback collection, iteration |

**Key distinctions by audience:**
- Business users: focus on planning phase and conceptual design
- Dedicated app makers: follow planning through deployment with Power Apps-specific guidance
- Full-stack developers: start at architectural design; review differences from traditional app development

---

## 14. Power Apps Coding Guidelines

Standards for building consistent, performant, and maintainable canvas apps.

### Covered Areas
- **Naming conventions** for objects, collections, and variables
- **Code organization** for screens and controls
- **Performance best practices** for formulas
- **Maintainability** standards for team development

### Recommended Tooling
- **Power CAT Toolkit** (available from marketplace): performs automated code reviews against these guidelines, flags non-compliant patterns, and helps maintain quality standards across projects

**Applicable to:** small businesses, corporations, and government entities building Power Apps solutions.

---

## 15. Source Control and Team Development

### Source Control Integration Options
1. **Power Platform Git Integration** -- built-in, direct connection to Git repositories
2. **Custom pipelines** using Build Tool tasks or YAML pipelines
3. **PAC CLI** commands for export, unpack, and commit workflows

### Branching Strategies
- **Trunk-based** -- single main branch with short-lived feature branches
- **Release branching** -- separate branches per release
- **Feature branching** -- isolated branches per feature

### Team Development Best Practices
- Avoid multiple people editing complex components (forms, flows, canvas apps) simultaneously
- Orchestrate changes to minimize merge conflicts
- Use source control as the single source of truth
- Break solutions into logical segments to reduce contention

---

## Quick Reference: ALM Tool Comparison

| Feature | Pipelines (In-Product) | Azure DevOps Build Tools | GitHub Actions |
|---------|----------------------|------------------------|----------------|
| Setup complexity | Low (minutes) | Medium (hours) | Medium (hours) |
| Target user | Makers, admins | Developers, DevOps | Developers, DevOps |
| External tool needed | No | Yes (Azure DevOps) | Yes (GitHub) |
| Cross-tenant deployment | No | Yes | Yes |
| Extensibility | Via Power Automate | Full pipeline customization | Full workflow customization |
| Approval workflows | Built-in delegated deployments | Azure DevOps approvals | GitHub environment protections |
| Source control integration | Optional extension | Native | Native |
| Cost | Included (Managed Environment license for targets) | Azure DevOps subscription | GitHub subscription |
